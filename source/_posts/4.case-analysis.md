---
title: 优秀案例分析与实战
date: 2018-10-16 11:10:10
categories:  
- Java
tags: 
- JVM
- Java
---

# 优秀案例分析与实战

## 案例分析
### 高性能硬件上部署服务器
比如一台高性能服务器有4个CPU，16G的物理内存，部署一个互联网应用服务器时将堆内存调整到固定12G，但是问题发生了，网站会经常出现停顿的问题出现，最后查出的问题是因为不停产生大对象导致频繁的FullGC，产生的停顿比较频繁。

控制FullGC的频率得看程序中对象是否符合“朝生夕灭”的原则，大对象存在的时间不能太长，尤其是不能有批量的大对象的产生，这样才能奖励FullGC的频率。

所以在高性能硬件上可以采用两种方式。
- 采用64位JDK部署。
- 使用虚拟机部署多个32位JDK应用（负载均衡）

但是使用64位jdk管理大内存就需要考虑以下问题。
- 较长时间的GC停顿。
- 64位性能普遍低于32位。
- 相同程序64位JDK比32位内存消耗大，主要是因为“指针膨胀”和占位补齐的原因。
- 需要保证程序稳定的运行，这种程序产生的dump文件可以达到十几G，导致无法生成快照文件，也无法分析。

所以通常使用多个虚拟机使用32为JDK的方式部署应用。
- 避免全局资源的访问竞争，比如同时访问同一个文件的问题。
- 很难充分利用连接池，比如一个连接池用满了，但是另一个节点连接空余很多（负载均衡问题）
- 大量使用本地缓存（比如HashMap的本地缓存），很容易造成内存浪费，所以可以考虑将本地缓存转化成一个集中式缓存。


### 集群间同步导致内存溢出
因为失败重发机制导致重发数据在堆中不断堆积，导致内存溢出。

### 堆外内存导致的溢出错误
可能是使用NIO的DirectByteBuffer导致直接内存溢出了。所有在实际生产环境中，除了堆、方法区占用内存，还要注意其他地方比较占用内存。
- 直接内存。溢出时会报OutOfMemeoryError。
- 线程堆栈，可以使用-Xss进行调节。
- Socket缓冲区，每个连接Receive和Send两个地方分别占用20-30K的空间，如果连接很多，占用内存也非常可观，如果无法为其分配内存，也会导致IOException:Too many connections.
- 虚拟机和GC.
- JNI代码，代码中调用本地方法的内存也不在堆中。

### 外部命令导致系统运行缓慢
Runtime.getRuntime().exec()调用占用CPU。

### 服务器JVM进程崩溃
在与别的服务器产生远程调用的时候，特别要注意消息堆积的问题。采用同步的远程调用会影响程序效率，所以采用异步调用。但是异步调用由于两方运行速度不一致，再加上调用很频繁的话，会导致等待的线程和Socket越积越多，最终导致JVM崩溃。 这时候就需要**消息队列**框架将远程通信改造成“生产者/消费者”模式，将压力分担到消息队列服务器中。

