---
title: JVM系列-垃圾收集器与内存分配策略 
date: 2018-10-14 11:10:10
categories:
- Java
tags: 
- JVM
- Java
---


# 垃圾收集器与内存分配策略

## 对象存活死亡
### 计数回收算法
一个对象在一个地方被引用，计数加1；引用失效，计数减1。计数为0时，进行回收。此算法效率高，被很多架构语言引用，但是无法解决一个问题就是相互引用的对象。
### 可达性分析算法
通过一系列“GC Roots”的对象作为起点，向下搜索，如果对象相对于GC Roots不可达，说明这个对象不再被使用，就会被判定为可回收的对象。
![image](https://note.youdao.com/yws/public/resource/dcff5c0bee1d6953fc0a1c4a49be81ca/xmlnote/C349EF41F2F9486085950B967BE079CE/3890)
### 引用
- 强引用：只代码中普遍存在的Object obj = new Object()，只要引用还有效，虚拟机永远不会回收这个对象。
- 软引用：描述有用但非必须的对象。在系统发生内存溢出前，将这些对象进行二次回收，如果内存还是不足，就会抛出内存溢出异常。

- 弱引用：只能存活到下一次GC发生时间。无论内存是否足够，都会回收掉弱引用对象。

- 虚引用：最弱的一种引用方式。无法通过虚引用得到一个对象实例，一个对象是否有虚引用的存在完全无法对其生命周期造成影响。唯一的作用在对象被回收时收到通知。

### 存活死亡
对象的finalize()方法只会被系统调用一次，下一次回收就不会调用finalize()方法。
### 回收方法区
方法区回收主要回收常量池和类信息。回收类信息的条件比较苛刻。
- 类所有实例均已被回收，堆中不存在此类的对象信息。
- 加载此类的ClassLoader被回收。
- 没有此类信息的引用存在。

大量使用反射、动态代理、CGlib等框架时，需要虚拟机拥有回收方法区的功能，防止溢出。

## 垃圾收集算法
### 标记-清除算法

### 复制算法

### 标记-整理算法

### 分代收集算法
根据堆内存分出的不同的内存代使用不同的收集算法，**新生代因为大部分对象都会被回收，只有少数对象存活，所以使用复制算法清除效率比较高**。老年代存活对象较多，使用使用标记整理或者标记清除算法比较好。

## HotSpot算法实现
### 枚举根节点
在对GC Roots进行可达性分析时，GC会停顿，保证分析结果的正确性，GC进行时会停止所有线程的运行。所以程序过于频繁的GC会导致程序效率运行缓慢。

### 安全点
Hotspot没有为每条指定都生成一个OopMap，只是在“特定位置”进行GC，特定的位置被称为**安全点**。

安全点的选定不能让GC等待太长时间，也不能太过于频繁影响程序效率。所以**safepoint**就会在那些执行时间比较长的指令处进行创建。长时间调用的特性就是“循环调用”，比如循环、方法调用、异常处理的地方。


## 垃圾收集器
![image](https://note.youdao.com/yws/public/resource/dcff5c0bee1d6953fc0a1c4a49be81ca/xmlnote/B1995015A6A84DE79DDF2CCD08115447/4011)

### Serial收集器
出现在JDK1.3.1之前唯一可用的收集器，只有一个单线程去进行垃圾收集，所以处理效率很低，十分影响程序的运行效率。
![image](https://note.youdao.com/yws/public/resource/dcff5c0bee1d6953fc0a1c4a49be81ca/xmlnote/81C1B511F9A146EAA5323A0A6C6E3023/4025)

**但是serial收集器相比于其他收集器存在的优势就是简单而高效，因为是单线程，没有线程交互的开销。适合在一些内存小的桌面应用中使用。**

### ParNew收集器
是Serial收集器的改进版本，是一种多线程收集器，适合应用在服务端应用中。

![image](https://note.youdao.com/yws/public/resource/dcff5c0bee1d6953fc0a1c4a49be81ca/xmlnote/960629CA715845A1BEDD2BB1FE3F8C21/4045)

除了Serial收集器外，它只能与老年代收集器CMS合作使用。但是CMS却无法与Parallel Scavenge配合使用。ParNew也是**XX:+UseConcMarkSweep**GC后默认的收集器。也可以使用**XX:+UseParNewGC**来强制使用它。

### Parallel Scavenge收集器
与ParNew类似，也是一种并行的收集器，但是与其他收集器尽量缩短回收时间和线程恢复时间，它更注重吞吐量。吞吐量指的是**用户代码执行时间**占**总代码时间**的**百分比**[用户代码执行时间/(用户代码执行时间 + 垃圾收集时间)]。

缩短停顿时间越适合用户交互相应。则高吞吐量可以高效的利用CPU，尽快的完成任务，主要适合后台计算而不需要太多交互的任务。

有两个参数可以精确的调整吞吐量，分别是控制GC最大停顿时间的**XX:MaxGCPauseMillis**和直接控制吞吐量大小的**XX:GCTimeRatio**。XX:MaxGCPauseMillis调小并不说肯定能让垃圾收集时间很快，GC停顿时间缩短是已牺牲吞吐量和新生代容量为代价，新生代容量小了，发生GC的频率也会增大，可能导致整体的GC时间变长。

### Serial Old收集器
Serial老年代版本，采用“标记整理”算法。适合在Client模式应用中使用。

### Parallel Old收集器
Parallel Scavenge老年代版本，采用“标记-整理”算法。Parallel Scavenge加上Parallel Old收集器是以吞吐量优先的组合，适合后台计算比较多而交互较少的Server应用中。

### CMS收集器
老年代收集器，是一种以获取最短系统停顿时间的收集器，目前集中互联网网站和B/S客户端中使用，这类服务器尤其重视服务器的响应速度。

"Conc Mark Sweep"字面理解就知道该收集器采用“标记-清除”算法。

![image](https://note.youdao.com/yws/public/resource/dcff5c0bee1d6953fc0a1c4a49be81ca/xmlnote/A043BE49F31D4908B7A8A668F3252A91/4124)

优点是并发收集、低停顿。但是缺点比较明显。
- 对CPU比较敏感。
- 无法清除浮动垃圾。
- 因为采用标记-清除算法，会产生大量内存碎片。

### G1收集器 ***
是一种并发收集器，可以应用在新生代和旧生代中，与CMS一样追求最短停顿时间的并发收集器。但是克服了CMS收集器中的缺点。


### 理解GC日志 ****

### 垃圾收集器相关的参数设置
![image](https://note.youdao.com/yws/public/resource/dcff5c0bee1d6953fc0a1c4a49be81ca/xmlnote/27A1C34A631447D88B3739DE0BE2E947/4132)
![image](https://note.youdao.com/yws/public/resource/dcff5c0bee1d6953fc0a1c4a49be81ca/xmlnote/83D70F38F4DA48B28D258D0F19338D88/4131)

## 内存分配与回收策略
自动内存管理解决两个问题：一个是如何给对象分配内存以及如何回收对象占用的内存。

### 对象优先在Eden分配
- **Minor GC**：是在新生代发生的回收动作，新生代对象大多数是“朝生夕灭”，所以GC动作非常频繁。
- **Major/Full GC**：是发生在老生代中回收动作，通常会发生一次Minor GC动作，但不是绝对发生。

大多数情况下，对象优先在Eden中分配，当Eden内存不足时，会触发一次Minor GC。

### 大对象直接进入老年代
大对象指的是大量需要连续内存的对象，比如数组和字符串。大对象对虚拟机是一个坏消息（**特别是那些“朝生夕灭”的“大对象”，避免程序中出现这种对象**），这些大对象容易导致内存还有很多空间需要提前触发GC从而“安置”它们（**新生代采用复制算法**）。虚拟机提供了一个参数-XX:PretenureSizeThreshold，对象大小大于其设定的值会直接被分配到老年代中，避免了大对象在新生代中频繁复制的问题。

### 长期存活的对象直接进入老年代
虚拟机可以识别哪些对象可以应该放到新生代，哪些对象放到老生代。所有针对每个对象都会有个年龄，如果对象出生的Eden并熬过了第一次Minor GC，并且Survivor可以容纳，年龄就会变成1，之后每经历一次Minotr GC年龄都会增加1，当达到一个年龄阈值（默认是15）会自动将该对象回收到老生代中。年龄阈值可以通过-XX:MaxTenuringThredhold来设置。

### 动态对象年龄判定
为了更好适应不同程序的内存状况，虚拟机并不是对象必须达到年龄才会进入老年代，当Survivor中相同年龄对象的数量大于Survivor容量一半，那么大于或等于此年龄的对象都将进入老年代。

### 空间分配担保
虚拟机在MinorGC前，会检查老年代的剩余空间是否大于新生代中对象大小之和，如果这个条件成立，如果条件成立就会正常MinorGC。如果不成立，则会查看HandlePromotionFailure设置，如果担保失败，虚拟机会检查老年代剩余空间是否大于历次晋升到老年代对象的平均值，如果成立就会尝试冒险再次进行MinorGC，如果小于或者HandlePromotionFailure不担保失败则会进行一次FullGC。