---
title: 分布式系统-远程调用
date: 2019-06-15 14:53:39
categories:
- Distributed System
tags:
- RPC
- RMI
---

## 请求-应答协议

这种通信设计用于典型的客户/服务交互中角色和信息的转换。通常情况下，请求-应答协议是同步的。同时也是可靠的，因为服务端的应答是对客户端一个有效的确认。异步的请求应答协议是可选择的。

该协议基于三个通信原语：doOperation、getRequest、sendReply，该协议将请求和应答进行匹配，用于提供传输保证。如果使用UDP数据报，通过该协议提供传输保证。

客户使用doOperation方法调用远程操作，方法参数指定远程调用服务器、待调用的操作以及请求的附加信息（参数）。其结果是包含应答内容的字节数组。doOperation方法向某个服务器发送请求信息，该服务器的IP地址、端口号以参数形式出现的远程引用中指定。在发送请求消息后，doOperation方法通过receive方法接受应答信息，并从应答信息中提取消息回传给调用者。

服务器进程通过getRequest方法获得请求信息，调用指定操作后，通过sendReply方法向客户端发送应答信息。原来的doOperation就会解除阻塞，客户端进程继续执行。

**消息标识符**    如果需要提供类似与可靠消息传递或请求-应答通信等额外特性，任何消息管理方法都要求每个消息必须有统一的消息标识符。通过消息标识符才可以引用消息。

**请求-应答协议故障模型**   如果三原语操作基于UDP数据报，那么他们会遇到相同的通信故障。

- 存在遗漏故障
- 没有保证消息按照其发送顺序传输

考虑到服务器故障或请求、应答消息被丢弃的情况，doOperation方法在等待服务器应答时使用超时处理。

**超时**   超时发生时，最简单的方法是立即返回给客户端一个异常信息。但是引起超时原因也可能是请求或应答消息丢失。为了避免消息丢失的可能性，doOperation方法会重复地发送请求消息直到收到应答或者有理由相信服务端未做应答而不是丢失消息。

**丢弃重复消息**    当请求消息重复传输时，服务器可能不止一次地接收到该消息。服务器可能接受第一个消息花费了比客户端的超时时间更长的时间执行。导致服务器可能不止一次地执行某个操作。为了避免这种情况，该协议设计能识别带有相同请求标识的连续消息，并过滤重复消息。如果服务器未应答则无需处理。

**丢失应答消息**    如果一个服务器收到重复的请求消息已经发送了应答，除非已经保存原先执行结果，否则它需要执行这个操作获得结果。一些服务器不止一次的执行操作得到了相同结果。一个**幂等操作**值执行一次的效果与多次执行的效果相同。如果服务器的操作都是幂等操作，就没有必要采取特殊举措防止操作多次执行。

**历史**    要求重新要求传输应答而不需要重新执行操作的服务器来说，可以使用历史。和历史使用相关的是内存开销，如果服务器不能确定合适不需要重新传输消息，历史的内存开销会很大。

**交互协议类型** 

- 请求-R协议 ： 基于UDP数据报实现，可能有通信故障
- 请求-应答（RR）协议：基于请求-应答协议，不需要特殊的确认步骤。因此UDP数据报丢失而引起的通信故障可以通过带有重新过滤请求消息和报错应答消息历史的方式避免。
- 请求-应答-确认应答（RRA）协议：该确认应答消息中包含了来自被确认应答消息的requestId。使服务器可以从历史中删除相应的条目。

**请求应答协议TCP流的使用**    接受数据报的缓冲区合适的大小经常很难确定。因为过程的参数或结果可能是任意长度，所以数据报的长度的限定不适用于透明RMI或RPC系统使用。

**基于TCP流的请求-应答协议**    为了避免实现多包协议，因为TCP流可以传输任意长度的参数和结果。尤其是在JAVA序列化是一种允许客户端、服务器之间传输任意长度消息的流协议。如果使用TCP协议，就能保证可靠的传输请求消息和应答消息，对于请求-应答协议就没有必要去处理消息的重传、重复消息的过滤、接收。

如果应用不要求TCP提供的所有机制，可以在定制UDP协议。例如sun nfs。

## 远程过程调用

使分布式编程和传统编程相类似，即实现了高级的分布透明性。这种相似性通过将传统的过程调用模型扩展到分布式环境方式实现。在RPC调用远程机器上的程序就像是调用本地的地址空间中一样。那么底层RPC系统就隐藏了分布式环境中重要的部分，包括对参数和结果编码和解码、消息传递以及保留过程调用的语义。

### RPC设计

RPC设计三个重要概念：

- RPC推动的编程风格-接口编程。
- 调用语义。
- 透明性问题和如何与远程过程调用关联。

**接口编程**   大多数现代编程语言提供了一个把一个程序组织称一系列能彼此通信的模块的方法。模块之间的通信可以依靠模块间的过程调用。为了控制模块可能的交互，必须为每一个模块定义显式的接口。模块接口可供其他模块方式访问过程和变量。实现后模块隐藏除接口以外所有的信息。只要模块接口名保持不变，可以随意改动实现而不影响调用者。

***分布式系统的接口***：在分布式程序中，模块能够运行在不同的进程中。每个服务器为客户端提供可调用方法集合。“服务接口（Service Interface）”这个术语涉及服务器提供的过程的说明、定义每个过程参数的格式。

在分布式编程中使用接口有很多好处，都源于接口和实现之间的分离。

- 程序员只需要关心服务提供的接口，不需要关心具体的实现。
- 推演（潜在的异构）分布式系统，无需关系编程语言和实现服务。
- 只要接口不变，实现可以改变。

服务接口的定义受分布式底层的影响：

- 一个模块无法访问另一个接口的变量。
- 本地调用过程中参数传递机制不适用与调用者和过程在不同的进程中。当某个参数为输入\输出时，请求和应答消息中都必须传递它的值。
- 一个过程的地址对于另一个进程是无效的，所以不能地址不能作为参数被调用或返回。

***接口定义语言***：RPC机制可以集成到某种语言中，只要该语言包含适当的定义接口的语法。并允许将输入和输入映射成该语言中正常的参数。这在只使用一种语言的系统中非常有用。

但是实际情况是每个系统可能都是使用不同的语言实现，这是使用一套跨平台的接口定义语言（Interface Definition Lanauage, IDL）十分有用。下面的代码就是GRPC的接口定义。

```grpc
syntax = "proto3";
package customer;

// The Customer sercie definition
service Customer {
    // Get all Customers with filter - A server-to-client streaming RPC.
    rpc GetCustomers(CustomerFilter) returns (stream CustomerRequest) {}

    // Create a new Customer - A simple RPC
    rpc CreateCustomer (CustomerRequest) returns (CustomerResponse) {}
}

message CustomerRequest {
    int32 id = 1;   // Unique ID number for a Customer.
    string name = 2;
    string email = 3;
    string phone = 4;

    message Address {
        string street = 1;
        string city = 2;
        string state = 3;
        string zip = 4;
        bool isShippingAddress = 5;
    }

    repeated Address addresses = 5;
}

message CustomerResponse {
    int32 id = 1;
    bool success = 2;
}

message CustomerFilter {
    string keyword = 1;
}
```

**RPC调用语义**    请求-应答模型中保证传输的主要方式有：

- 重发请求消息
- 过滤重复消息
- 重传结果

将这些选择（**容错措施**）组合便导致了调用者所见到的远程调用可靠性的各种语义。下面的表格给除了各种组合可能的语义。

| 重发请求消息 | 过滤重复请求 | 重新执行或重传应答 | 调用语义 |
| ------------ | ------------ | ------------------ | -------- |
| N            | 不支持       | 不支持             | 获取     |
| Y            | N            | 重新执行过程       | 至少一次 |
| Y            | Y            | 重传应答           | 至多一次 |

**透明性**   

RPC致力于提供最少的位置透明性和访问透明性，隐藏过程的物理位置，也以同样的方式访问本地和远程的过程。

同样，远程调用失败的概率要更高，其中涉及了另一台计算机，另一个进程。不论选择哪种语义调用，总有获取不到结果的情形，而且在出现故障的情况下，无法判别故障是源于网络失败还是源于远程服务器进程故障。这要求发起远程调用的程序能从故障中恢复。

远程调用的延迟要远比本地调用大上好几个数量级，因此远程调用时需要将延迟因素考虑进去。例如尽可能减少远程交互。IDL的设计者也面临远程调用是否透明的抉择，例如，当客户与远程无法通信时，就抛出一个异常共客户端处理。IDL也可以提供一种指定过程调用语义的机制。

## 远程方法调用

远程方法调用（Remote Method Invacation）RPC和RMI之间具有相似性，只是RMI被扩展到了对象的层面。访问对象可以调用远程对象的方法。RMI和RPC的共性如下：

- 都支持接口编程。
- 都是典型的请求-应答协议构造，并提供一系列如最少一次、至多一次的调用语义。
- 都提供相似的透明性。

下面的不同会在复杂的分布式应用带来额外的功能：

- 能够使用所有面向对象编程的功能。包括类、对象、继承的使用。
- 基于RMI系统中的所有对象都有唯一的对象引用（无论是远程还是本地）。对象引用可以当做参数进行传递，因此RMI比RPC提供更丰富的参数传递语义。

**创建代理类、分发器类和骨架类**     在RMI使用的代理类、分发器类和骨架类由接口编译器自动创建。

动态调用：可替换代理的选择，上面提到的代理是静态的，即代理类是通过接口定义生成的，并编译到客户端代码中。但是有些情况下对象的远程接口在编译期无法确定。



