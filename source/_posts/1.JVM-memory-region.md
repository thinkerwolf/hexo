---
title: JVM系列-内存区域
date: 2018-10-13 10:10:10
categories:
- Java
tags: 
- JVM
- Java
---


# JVM内存区域及泄露异常
## JVM运行数据区域
![image](/images/jvm/jvm1.png)

### 程序计数器
比较小的一块内存区域，可以理解为线程执行字节码的行号，在执行字节码时都需要通过改变这个计数器来执行跳转、分支、循环、异常处理、线程恢复。

**因为Java虚拟机的多线程是通过轮流切换并分配CPU执行时间方式来实现的，所以对于任何一个时刻，处理器只会处理一个线程中的流程**，所以每个线程恢复时就需要一个计数器用来恢复。每个线程专享一个程序计数器。

程序计数器是整个Java虚拟机中唯一没有定义OutOfMemoryError异常的内存区域。
### 虚拟机栈
与程序计数器类似，也是线程私有的，生命周期与线程相同。虚拟机栈描述的是方法的**内存模型**，每个方法执行时都会创建一个**栈帧**用来存储局部变量表、操作数栈、动态链表、方法出口等信息。

Java虚拟机对虚拟机栈定义了两种异常，当栈深度大于虚拟机允许的深度，就会抛出StackOverflowError。当需要扩展的内存超出定义的最大内存，会抛出OutOfMemoryError。
### 本地方法栈
与虚拟机栈类似，虚拟机栈执行的时字节码方法，而本地方法栈执行的是Native方法。也会抛出StackOverflowError和OutOfMemoryError。
### 堆
是JVM中内存最大的一块，是所有线程共享的一块内存区域，几乎所有的对象实例和数组都是分配在上面，堆内存是垃圾收集器主要管理的区域，现代的JVM都是使用分代收集算法，所以堆可分为新生代和旧生代，新生代再细分可以分为Eden、From Survivor、To Survivor。

堆无法分配或扩展时会抛出OutOfMemoryError异常。

### 方法区
与堆一样，是线程共享区域，存储**虚拟机加载的类信息**、**常量**、**静态变量**、**即时编译后的代码**等。

内存不足无法扩展抛出OutOfMemoryError异常。

### 运行时常量池
是方法区中的一个部分，Class文件除了有版本、属性、方法、接口等信息外，还有一项就是常量池，用于存放将编译期间产生的符号引用和字面量。

运行时常量池具有动态性，String类中intern方法就是对常量池进行操作。内存不足抛出OutOfMemoryError异常。

### 直接内存区（堆外内存区）
NIO中的DirectByteBuffer就是直接对堆外内存进行操作。内存不足抛出OutOfMemoryError异常。


## JVM对象创建
### 对象的创建过程
虚拟机碰到一个new时，**先检查指令参数是否在常量池中定位到一个符号，并检查符号引用代表的类是否被加载、解析和初始化过，如果没有则进行类加载过程**。

**随后为对象划分堆内存**，对象所需的内存在类加载过程便已确定。对象内存划分方式有两种。
- 如果是一块规整的内存，可以使用“指针碰撞”的方式，即在空闲内存中向后移动新对象需要的内存大小。
- 如果内存是碎片化的，则虚拟机需要维护一个**空闲列表**，由虚拟机决定划分一块足够大的内存给新生对象。**决定Java堆是否规整由采用哪种垃圾收集器决定。**

创建对象是及其频繁的过程，可能有多个线程同时创建对象，这时就需要保证内存划分的线程安全性。有两种措施保证线程安全。
- **在分配内存空间处增加同步处理**-虚拟机通过CAS和失败重试保证操作原子性。
- **为每个线程划分独立内存区域TLAB**，创建新对象在制定的TLAB划分内存，只有在内存不足划分新的TLAB时才会进行同步操作。

内存划分后，虚拟机为对象进行必要的设置，例如这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码，对象的**GC分代年龄信息**。从虚拟机角度对象已经创建完成，但是对于程序角度还未完成，这是需要调用<init>方法完成对象初始化。

### 对象的内存布局
对象的内存区域分为三块：**对象头**，**实例数据**和**对齐填充**。

对象头包含两部分。
- 一部分存储对象自身的运行数据，比**如哈希码（hashCode）**、**GC分代年龄**、**锁状态标志**、**线程持有锁**、**偏向线程ID**、**偏向时间戳**等。这部分数据在32bit和64bit虚拟机分别是32位和64位大小。
- 另一部分就是存储引用类信息的指针。

实例数据部分是对象运行时真正的有效内容，也是对象各种类型字段的内容，有自定义的，也有从父类继承下来的，都需要被记录下来。

### 对象的访问定位
通过栈区的引用来对对象进行访问操作。

![image](/images/jvm/jvm2.png)

![image](/images/jvm/jvm3.png)

## OutMemoryError实战
### 堆溢出
Java的堆时存储对象的区域，不断的新建对象就会引发堆溢出，-Xms和-Xmx参数是设置堆大小的虚拟机参数，通过参数-XX:HeapDumpOnOutOfMemoryError，当堆溢出时自动dump文件用于分析。

解决这个区域的问题，首先利用工具（如Eclipse Memory Analyzar）将dump出的内存快照文件分析出来，在确认时内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）问题。

- 内存泄露，通过GC Roots查看收集器无法回收哪个对象。
- 内存溢出，表示堆内存容量过小，通过适当调节参数增大堆内存大小。

### 虚拟机栈和本地方法栈溢出
一般虚拟机不区分虚拟机栈和本地方法栈，通常设置栈大小的虚拟机参数时-Xss。

单线程下比较难重现OutOfMemoryError，一般会产生StackOverflow错误。但是在多线程的情况下就会产生OutOfMemoryError错误。

**Java提供参数限制堆和方法区的内存，2G内存减去-Xmx和-MaxPermSize，剩下的内存由虚拟机栈和本地方法区瓜分。每个线程分到的栈容量就越大，可创建的线程数量就越少。** 

如果是StackOverflowError通过查看堆栈信息可以比较容易定位问题所在，但是因为线程过多导致的内存溢出，这时可以通过减少堆容量和栈容量来换取更多的线程。

### 方法区和运行时常量池溢出
利用cglib频繁的动态创建新的类性信息可能导致内存溢出，大量的JSP页面和OSGI技术（被不同的类加载器加载也算不同的类性）也可能导致方法区内存溢出。

### 直接内存溢出
直接内存溢出，查看因为使用NIO的DirectByteBuffer导致的问题。
