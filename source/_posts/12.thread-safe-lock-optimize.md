---
title: JVM系列-线程安全与锁优化
date: 2018-10-30 11:10:10
categories:  
- Java
tags: 
- JVM
- Java
---

# 线程安全与锁优化

先保证并发的安全性，再去追求并发的高效性。
## 线程安全
当多个线程访问一个对象时，如果不考虑这些线程再允许时环境下的调度和交替执行，也不需要进行额外的同步，或者再调用方法进行任何其他的协调操作，调用这个对象的行为豆可以获得正确的结果，那这个对象是线程安全的。

### Java语言中的线程安全
为了更加深入理解线程安全，可以不把线程安全当作一个非真即假的二元排他选项来看，按照线程安全的“安全程度”由强至弱排序，可以将Java语言中各种操作共享的数据分为以下5类：**不可变**、**绝对线程安全**、**相对线程安全**、**线程兼容**和**线程对立**。

#### 不可变
在Java语言中，不可变的（Immutable）的对象一定是线程安全的，只要在一个不可变的对象被正确的构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远不会改变。“不可变”带来的安全性最简单和纯粹的。通过final关键字保证不可变。

#### 绝对线程安全
绝对的线程安全完全满足线程安全的定义，通常需要付出很大的，甚至不切实际的代价。在Java API中标注自己是线程安全的类，大多不是绝对的线程安全。

针对java.util.Vector是一个线程安全的容器，效率很低，但是是绝对的安全。

#### 相对线程安全
相对的线程安全就是我们通常意义上所讲的线程安全，他需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能在调用端使用额外的同步手段来保证调用的正确性。比如Vector、HashTable、ConcurrentHashMap。

#### 线程兼容
线程兼容指对象本身不是线程安全的，但是可以通过在调用端正确使用同步手段来保证对象在并发环境中可以安全地使用。

#### 线程对立
线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发适用的代码。一个线程对立的例子是Thread类的suspend()和resume()方法。

### 线程安全的实现方法
如何实现线程安全和虚拟机如何实现同步与锁这两者都会有所涉及。
#### 互斥同步
互斥同步（MutuaFExclusion & Sychronization）是常见的一种并发正确保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程适用。而互斥是实现同步的一种手段，临界区(Critical Section)、互斥量（Mutex）、和信号量（Semaphore）都是主要的互斥实现方式。互斥是因，同步是果；互斥是方法，同步是目的。

最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译后，会在同步块前后形成monitorrenter和monitorexit这两个字节码指令。这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果没有指定，就是根据sychronized修饰的是实例方法还是类方法。

Sychronized同步块对同一条线程是可重入的。Java的线程是映射到操作系统的原生线程上的，如果阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到内核态中，状态转换需要耗费很多的处理器时间。对于简单的同步代码块，状态转换消耗的时间可能比用户代码执行的时间还长。所以synchronized是Java语言中一个重量级的操作。

除了Sychronized之外，我们还可以使用java.util.concurrent（JUC）包中的重入锁来实现同步。一个是API层面的互斥锁，另一个表现为原生语法层面的互斥锁。相比synchronized，ReentrantLock增加一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件。
- 等待可中断是指持有锁的线程长期不释放锁，正在等待的线程可以选择放弃等待。
- 公平锁指多个线程等待一个锁，必须按照申请锁的时间顺序来依次获得锁。
- 绑定多个条件值一个ReentrantLock可以同时绑定多个Condition对象，而sychronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多个条件关联，不得不额外添加一个锁，而ReentrantLock无需这么做，只需多次调用newCondition()方法即可。

jdk1.6之后加入了许多对sychronized优化的措施，sychronized和ReentrantLock的性能基本完全持平了，所以JDK1.6之后性能因素不再是选择ReentrantLock的理由了，所以在sychronized能实现需求的情况下，优先考虑使用sychronized来同步。

#### 非阻塞同步
互斥同步最主要的问题就是进行线程阻塞带来的性能问题，这个同步也叫阻塞同步。从处理方式来讲，互斥同步属于一种悲观的并发策略，总是认为不去做正确的同步措施，肯定就会出现问题，无论是否共享数据真的会出现竞争。随着指令集的发展，我们有另外一个选择：基于冲突检测的乐观并发策略，通俗来说，就是先进行操作，如果没有其他线程争用共享数据，操作成功；如果共享数据有争用，产生冲突，那就再采取补偿措施（比如不断重试，直到成功），这种乐观的并发策略许多实现都不需要挂起线程。这种称为非阻塞同步。

为什么乐观锁并发需要“硬件指令集的发展”。因为需要操作和冲突检测这两个步骤具备原子性，如果再使用互斥同步就失去意义了，所以我们只能靠硬件来完成这件事情。硬件上可能需要多次完成的操作的行为在语义上值需要一条指令即可完成。
- 测试并设置。
- 获取并增加。
- 交换。
- 比较并交换。
- 加载连接/条件存储。

CAS指令需要3个操作数，分别是内存位置（简单理解为内存地址V）、旧的预期值（A）和新值（B）。CAS执行是，当且仅当V符合旧预期值，处理器用新值B更新V值，否则不执行更新，但是无论更新V的值，都会返回V的旧值。

比如在incrementAndGet()方法中在一个无限循环中，不断尝试将一个比当前值大于1的新值赋值给自己，如果失败，说明获取设置操作有了修改，于是再次循环进行下一次操作，直到设置成功为止。

#### 无同步方案
Java语言中，如果一个变量要被多个线程访问，可以使用volatile关键字声明为“易变得”；如果一个变量要被一个线程独享，可以使用java.lang.ThreadLocal类来实现线程本地存储功能。
volitile使用场景 //

## 锁优化
JDK1.5到JDK1.6，HotSpot在这个版本花费大量精力去实现各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些都是为了在线程间更高效的共享数据。

### 自旋锁与自适应自旋
如果物理机器有一个以上处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要执行一个忙循环，这就是自旋锁。

可以使用-XX:++UseSpinning参数来开启自旋锁。自旋锁不能代替阻塞，自旋锁虽然避免了线程切换开销，但是要占用处理器时间，如果锁被占用时间短，自旋等待效果很好。反之，如果锁占用时间很长，自旋的线程只会白白消耗CPU资源做无用功。所以，自旋锁必须有个等待的时间限度。

JDK1.6引入自适应自旋锁。意味着自旋的时间不再固定，由前一次在同一个锁上的自选时间及锁的拥有者的状态来决定。有了自适应自旋，随着程序运行和性能监测信息的不断完善，虚拟机对程序锁的状况预测就越来越准确。

### 消除锁
消除锁是指虚拟机即时编译器在运行时，对一些代码上同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除主要判定依据来源于逃逸分析的数据支持。分析一段代码，堆上的代码会不会逃逸出去从而被其他线程访问到。如果不会访问到，就可以认为是线程私有的，直接进行消除。

### 锁粗化
编写代码的时候，总是推荐将同步块的作用范围限制尽量小，这样是为了需要同步的操作数量尽可能小，如果存在锁竞争，等待锁也能尽快拿到锁。

但是如果一系列连续的都对同一个对象反复加锁解锁，即使没有线程竞争，也会因为频繁进行互斥同步操作造成不必要的性能损失。所以如果虚拟机检测到一连串零碎的操作对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列。

### 轻量级锁
轻量级锁不是用来代替重量级锁的，本意是在没有多线程竞争前提下，减少传统的重量锁使用操作系统互斥量产生的性能消耗。

### 偏向锁

