---
title: JVM系列-虚拟机类加载机制
date: 2018-10-18 11:10:10
categories:  
- Java
tags: 
- JVM
- Java
---

# 虚拟机类加载机制

## 类加载时机
类从加载到虚拟机中，到卸载出虚拟机中会经历7个生命周期：加载、验证、准备、解析、初始化、使用、卸载。

![image](https://note.youdao.com/yws/public/resource/dcff5c0bee1d6953fc0a1c4a49be81ca/xmlnote/49302D40B180494592D60FF0BF6EC1CE/5166)

Java虚拟机并没有强制约束程序加载的时机，每个虚拟机实现可以自由发挥，但是初始化阶段Java虚拟机则规定了有且只有5项必须初始化的时机，当然“加载”、“验证”、“准备”、必须在前面。
- 遇到new、getstatic、putstatic和invokestatic这四个指令必须初始化（static final修饰的除外，因为在编译期间被加载到方法取了）。
- 使用java.lang.reflect包反射调用类的信息时必须先初始化。
- 初始化一个类，如果发现父类没有初始化，先初始化父类。
- main启动类初始化。
- JDK1.7动态语言支持。

## 类加载过程
### 加载
“加载”是“类加载”中的一个过程，不要混淆。虚拟机在加载阶段需要完成以下三件事情。
- 通过类的全限定名找到相应的二进制流。
- 将静态的二进制流转化成方法区运行时数据结构。
- 在内存中生成java.lang.Class对象用来访问方法去数据结构的入口。

### 验证
是“连接”的第一步，确保Java字节流信息是否符合要求。“验证”阶段是十分重要的，这个阶段是否严谨决定了JVM能否承受攻击。如果输入的字节流不符合JVM的格式，则会抛出java.lang.VerifyError异常。大体上验证包括以下4部分。
#### 文件格式验证
验证字节流是否符合Class文件格式规范。
- 是否以魔数开头。
- 主、次版本号是否再虚拟机处理范围内。
- 常量池的常量中是否有不被支持的常量类型。
- 指向常量池的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- CONSTANT_Utf8_info是否有不符合UTF-8编码的数据。
- Class文件中各个部分及文件本身是否有被删除或附加的其他信息。
#### 元数据校验
对字节码描述的信息进行语义分析。
- 这个类是否有父类。
- 这个类的父类是否继承了不被运行继承的类。（final）
- 如果这个类不是抽象类，是否实现了父类或接口中的方法。
- 类中的字段、方法是否与父类产生矛盾。
#### 字节码验证
字节码验证是整个验证过程中最复杂的一个阶段，通过数据流和控制流分析，确定程序的语义是否是合法、符合逻辑的。
- 任意时刻操作数栈的数据类型与指令代码都能配合工作。
- 保证跳转指令不会跳转到方法体以外的字节码指令上。
- 保证方法体中的类型转换是有效的。
#### 符号引用校验
最后一个校验发生在虚拟机将符合引用转化为直接引用的时候，对匹配信息进行校验。
- 符号引用中通过字符串描述的全限定名是否能找到对应的类。
- 指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。
- 符号引用中的类、方法、字段的访问性能否被当前类访问。

如果无法通过符号引用，则抛出java.lang.IncompatibleClassChangeError，java.lang.NoSuchMethodError，java.lang.NoSuchFieldError，java.lang.IllegalAccessError。

### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。要注意两点，首先分配内存的只是类变量（static修饰的变量），不包括实例变量，实例变量在对象实例化时随着对象一起分配在Java堆中。假设一段代码
``` java
public static int num = 123;
```
在准备阶段num的值0而不是123，因为给“num”赋值123是通过putstatic指令完成，而putstatic指令是放在编译的<client>()方法中，而这个是在初始化阶段才会执行。
``` java
public final static int num = 123;
```
但是对“num”变量加上“final”修饰时，“num”才会变成123。

### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

- 符号引用：符号引用是以一组符号来描述所引用的目标，可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。
- 直接引用：可以是直接指向目标的指针、偏移量、相对偏移量或者能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的。

虚拟机中并未规定的具体时间，只要求再执行**anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、inokespecial、invokestatic、invokevirtual、lcd、lcd_w、multianewarray、new、putfield和putstatic**这16个用于操作符号引用字节码指令之前，对他们所使用的符号引用进行解析。

#### 类或接口的解析
假设当前代码所处的类为D，如果要把一个为解析过的符号引用N解读为一个类或接口C的直接引用，虚拟机需要完成一下3个步骤。
1. 如果C不是一个数组类型，虚拟机将把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，出发其他相关类的加载动作。一但这个过程出现错误，解析过程失败。
2. 如果C是一个数组类型，并且数组元素类型为对象，按照第1点规则加载元素类型，接着虚拟机生成此维度的数组对象。
3. 如果解析没出现异常，那么C在虚拟机中已变成一个有效的类或接口了。

#### 字段解析
首先对字段表内的class_index找到相应的CONSTANT_Class_info符号引用进行解析，就是字段所属的类或接口的符号引用。这个字段所属的类或接口用C表示，虚拟机按照一下步骤对C进行后续字段的搜索。
1. 如果C本身包含了简单名称和字段描述符与目标相匹配，查找结束。
2. 如果在C中实现的接口，将会按照继承关系从下往上递归搜索接口和父接口，如果接口中包含了简单名称和字段描述都与目标匹配，查找结束。
3. 否则，如果C不是java.lang.Object的话，按照继承关系从下往上搜索父类，如果父类包含了简单名称和字段描述都与目标相匹配，查找结束。
4. 否则，查找失败，抛出java.lang.NoSuchFieldError。

#### 类方法解析
类方法的第一个步骤与字段解析一样，解析成功后，按照一下步骤进行后续类方法搜索。
1. 类方法和接口方法符号引用的常量类型定义是分开的，如果class_index的索引C是个接口，抛出java.lang.IncompatibleClassError异常。
2. 如果第一步通过，下面的步骤与字段解析相同。
3. 最后，如果查找失败，直接抛出java.lang.NoSuchMethodError异常。

#### 接口方法解析
与类方法解析类似。

### 初始化
类初始化时加载过程的最后一步。到了初始化阶段，才真正的执行类中定义的Java程序代码。初始化阶段是执行类构造器<client>()方法的过程。
- <client>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问静态语句块之前的变量，定义在它之后的变量，可以赋值，但是不能访问。
- <client>()方法与类的构造函数不同，不需要显式的调用父类构造器，虚拟机会在子类<client>()之前，父类的<client>()已经执行完毕。
- 因为父类的<client>()先执行，所有父类的静态语句块要休先于子类的变量赋值操作。
- <client>()方法如果对于类或接口不是必须的，如果一个类没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<client>()方法。
- 虚拟机会保证一个类的<client>()方法在多线程环境中被正确的加锁、同步。所以如果多个线程同时初始化一个类，那么只有一个线程去执行这个类的<client>()方法。

## 类加载器
对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其他Java虚拟机中的唯一性。比较两个类Class是否相等，必须确定是否被同一个虚拟机加载。

这个所指的“相等”，包括代表类的Class对象的**equals()**方法、**isAssignableFrom()**方法、**isInstance()**方法的返回结果，也包括**instanceof**关键字的判定等情况。

### 双亲委派模型
从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是**启动类加载器**（Bootstrap Classloader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他类加载器，都是由Java语言实现，独立于虚拟机外部，全部都继承与**java.lang.ClassLoader**。

从开发人员的角度来看，类加载器还可以划分得更细致一些。
- 启动类加载器：这个类负责将存在<JAVA_HOME>\lib目录中，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法在程序中引用。
- 扩展类加载器：这个是由sun.misc.Launcher$ExtClassLoader实现的，负责加载<JAVA_HOME>\lib\ext目录中的或者被java.ext.dirs系统变量指定的路径中的所有类库，开发这可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader实现。这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值。负责加载用户类路径（ClassPath）上所指定的类库。
- 自定义类加载器。

双亲委派模型的过程是：如果一个类加载器收到了类加载的请求，首先不会自己尝试加载这个类，而是先把这个请求委派给父类加载器去完成，所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器无法完成这个加载请求，自加载器才会尝试自己去加载。

使用双亲的一个好处就是Java类随着他的加载器一起具备了一种带有优先级的层次关系。比如java.lang.Object存放在rt.jar中，无论哪一个类加载器加载这个类，最终都是委派给处于顶端的启动类加载器进行加载，所以Object类在各种类加载器环境中都是同一个类，防止代码类混乱。